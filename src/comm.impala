struct MPIComms {
    world : COMM_COMM,
}

struct MPIOps {
    max : COMM_Op,
    sum : COMM_Op,
}

// TODO should be autogenerated, differs for other MPI implementations (e.g. MPICH)
struct MPIStatus {
    source : i32,
    tag : i32,
    error : i32,
    // internal to openmpi, do not access
    _cancelled : i32,
    _ucount : u64
}

struct MPIStatuses {
    ignore : &mut MPIStatus,
}

struct Communicator {
    comms : MPIComms,
    ops : MPIOps,
    status : MPIStatuses,
    int_t : COMM_Datatype,
    double_t : COMM_Datatype,
    char_t: COMM_Datatype,
    parallel_reduction_buffer: Buffer,

    //first parameter: &int for number of Nodes, second parameter: &int for current rank
    init : fn(&mut i32, &mut i32) -> i32,
    initWithoutVars: fn() -> i32,
    comm_size : fn(&mut i32) -> i32,
    comm_rank : fn(&mut i32) -> i32,
    get_cur_rank: fn() -> i32,
    get_number_of_nodes: fn() -> i32,
    allreduce : fn(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op) -> i32,
    send : fn(COMM_Buf, i32, COMM_Datatype, i32, i32) -> i32,
    recv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32, &mut MPIStatus) -> i32,
    irecv : fn(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_REQUEST) -> i32,
    wait : fn(COMM_REQUEST, &mut MPIStatus) -> i32,
    probe: fn(i32, i32, &mut MPIStatus) -> i32,
    get_count: fn(&mut MPIStatus, COMM_Datatype, &mut i32) -> i32,
    gather: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32) -> i32,
    allgather: fn(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype) -> i32,
    barrier : fn() -> i32,
    wtime : fn() -> f64,
    finalize : fn() -> i32,
    create_request: fn() -> COMM_REQUEST,
    parallel_reduction: fn(Buffer, &mut [f64], &mut [f64], int, fn(double, double) -> double) -> double,
    get_vector_length: fn() -> i32,
    vectorize: fn(int, int, fn(int) -> ()) -> (),
}

type COMM_COMM = &();
type COMM_Datatype = int;
type COMM_Op = &();
type COMM_REQUEST = &();
type COMM_STATUS = &mut [i8];
type COMM_Buf = &[i8];
type COMM_MutBuf = &mut [i8];

extern "C" {
    fn MPI_Init() -> i32;
    fn MPI_Initialized(&mut i32) -> i32;
    fn MPI_Comm_size(COMM_COMM, &mut i32) -> i32;
    fn MPI_Comm_rank(COMM_COMM, &mut i32) -> i32;
    fn MPI_Allreduce(COMM_Buf, COMM_MutBuf, i32, COMM_Datatype, COMM_Op, COMM_COMM) -> i32;
    fn MPI_Send(COMM_Buf, i32, COMM_Datatype, i32, i32, COMM_COMM) -> i32;
    fn MPI_Recv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn MPI_Irecv(COMM_MutBuf, i32, COMM_Datatype, i32, i32, COMM_COMM, COMM_REQUEST) -> i32;
    fn MPI_Wait(COMM_REQUEST, COMM_STATUS) -> i32;
    fn MPI_Probe(i32, i32, COMM_COMM, COMM_STATUS) -> i32;
    fn MPI_Get_count(COMM_STATUS, COMM_Datatype, &mut i32) -> i32;
    fn MPI_Gather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, i32, COMM_COMM) -> i32;
    fn MPI_Allgather(COMM_Buf, i32, COMM_Datatype, COMM_MutBuf, i32, COMM_Datatype, COMM_COMM) -> i32;
    fn MPI_Barrier(COMM_COMM) -> i32;
    fn MPI_Wtime() -> f64;
    fn MPI_Finalize() -> i32;
    fn MPI_Finalized(&mut i32) -> i32;
    // wrappers in mpi.cpp for getting MPI constants
    fn get_mpi_comm_world() -> COMM_COMM;
    fn get_mpi_int() -> COMM_Datatype;
    fn get_mpi_double() -> COMM_Datatype;
    fn get_mpi_char() -> COMM_Datatype;
    fn get_mpi_max() -> COMM_Op;
    fn get_mpi_sum() -> COMM_Op;
    fn get_mpi_status_ignore() -> COMM_STATUS;
}

extern fn start_COMM() -> i32 {
    //trick allows two call init multiple times
    let mut initialized = 0;
    let mut status = 0;
    MPI_Initialized(&mut initialized);
    if(initialized == 0) {
        status = MPI_Init();
    }
    status
}

fn @comm() -> Communicator {
    Communicator {
        comms : MPIComms {
            world : get_mpi_comm_world(),
        },
        ops : MPIOps {
            max : get_mpi_max(),
            sum : get_mpi_sum(),
        },
        status : MPIStatuses {
            ignore : get_mpi_status_ignore() as &mut MPIStatus,
        },
        double_t : get_mpi_double(),
        int_t : get_mpi_int(),
        char_t: get_mpi_char(),
        parallel_reduction_buffer: create_double_array_buffer(get_num_threads()),

        init : @|numNodes,rank| {
            let status = start_COMM();
            MPI_Comm_size(get_mpi_comm_world(),numNodes);
            MPI_Comm_rank(get_mpi_comm_world(),rank);
            status
        },
        initWithoutVars: || {
            start_COMM()
        },
        comm_size : @|numNodes| {
            MPI_Comm_size(get_mpi_comm_world(),numNodes)
        },
        comm_rank : @|rank| {
            MPI_Comm_rank(get_mpi_comm_world(),rank)
        },
        get_cur_rank: @|| {
            let mut curRank = -1;
            MPI_Comm_rank(get_mpi_comm_world(),&mut curRank);
            curRank
        },
        get_number_of_nodes: @|| {
            let mut numNodes = -1;
            MPI_Comm_size(get_mpi_comm_world(),&mut numNodes);
            numNodes
        },
        allreduce : @|sendbuf, recvbuf, count, datatype, op| {
            MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, get_mpi_comm_world())
        },
        send : @|buf, count, datatype, dest, tag| {
            MPI_Send(buf, count, datatype, dest, tag, get_mpi_comm_world())
        },
        recv : @|buf, count, datatype, source, tag, status| {
            MPI_Recv(buf, count, datatype, source, tag, get_mpi_comm_world(), status as COMM_STATUS)
        },
        irecv : @|buf, count, datatype, source, tag, request| {
            MPI_Irecv(buf, count, datatype, source, tag, get_mpi_comm_world(), request)
        },
        wait : @|request, status| {
            MPI_Wait(request, status as COMM_STATUS)
        },
        probe: @|source, tag, status| {
            MPI_Probe(source, tag, get_mpi_comm_world(), status as COMM_STATUS)
        },
        get_count: @|status, datatype, count| {
            MPI_Get_count(status as COMM_STATUS, datatype, count)
        },
        gather: @|sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root| {
            MPI_Gather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, root, get_mpi_comm_world())
        },
        allgather: @|sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype| {
            MPI_Allgather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype, get_mpi_comm_world())
        },
        barrier : @|| {
            MPI_Barrier(get_mpi_comm_world())
        },
        wtime : MPI_Wtime,
        finalize : @|| {
            //trick allows to call finalize multiple times
            let mut finalized = 0;
            MPI_Finalized(&mut finalized);
            if(finalized == 0) {
                MPI_Finalize()
            }
            else {
                0
            }
        },
        create_request: @|| {
            &()
        }
    }
}

;
